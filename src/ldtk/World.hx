package ldtk;

import ldtk.Json;

class World {
	#if !macro

	var untypedProject: ldtk.Project; // WARNING: the var type isn't the "complete" project type as generated by macros!
	var json : ldtk.Json.WorldJson;
	var _untypedLevels : Array<ldtk.Level>;

	/** Index in project `worlds` array **/
	public var arrayIndex(default,null) : Int;
	public var identifier(default,null) : String;
	public var iid(default,null) : String;

	public var layout: WorldLayout;
	public var gridWid : Int;
	public var gridHei : Int;



	public function new(project:Project, arrayIdx:Int, json:ldtk.Json.WorldJson) {
		this.untypedProject = project;
		this.arrayIndex = arrayIdx;
		if( json!=null )
			fromJson(json);
	}

	@:keep public function toString() {
		return 'ldtk.World[$identifier, $layout, ${_untypedLevels.length} levels]';
	}

	function fromJson(untypedJson:Dynamic) {
		this.json = untypedJson;
		iid = json.iid;
		identifier = json.identifier;
		layout = WorldLayout.createByName( Std.string(untypedJson.worldLayout) );
		gridWid = json.worldGridWidth;
		gridHei = json.worldGridHeight;


		// Populate levels
		_untypedLevels = [];
		var idx = 0;
		for(json in json.levels)
			_untypedLevels.push( _instanciateLevel(untypedProject, idx++, json) );
	}


	function _instanciateLevel(project:ldtk.Project, arrayIndex:Int, json:ldtk.Json.LevelJson) {
		return null; // overriden by Macros.hx
	}

	#end


	@:allow(ldtk.macro.TypeBuilder, ldtk.Project)
	static function createDummyJson(projectJson:ProjectJson) : WorldJson {
		var untypedJson : Dynamic = projectJson;
		return {
			iid: "Default_iid",
			identifier: "Default",

			worldLayout: WorldLayout.createByName( Std.string(untypedJson.worldLayout) ),
			worldGridWidth: projectJson.worldGridWidth,
			worldGridHeight: projectJson.worldGridHeight,

			defaultLevelWidth: projectJson.defaultLevelWidth,
			defaultLevelHeight: projectJson.defaultLevelHeight,
			levels: projectJson.levels,

		}

	}
}
